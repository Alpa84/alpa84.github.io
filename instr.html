<!DOCTYPE html>
<html lang=en>

<head>
    <title>Touch Events tutorial</title>
    <meta name="viewport" content="width=device-width">
    <style>
        body {
            margin: 0em;
            padding: 0em;
        }
        div {
            margin: 0em;
            padding: 0em;
        }
        .octaveContainer {
            width: 30vw;
            float:left;
            padding: 0px;
        }
        .key {
            padding: 0em;
            height: calc(90vh / 12);
            font: 15px;
            background: white;
            border: 1px solid black;
        }
        .white {
            background: white;
        }
        .black {
            background: gray;
        }
    </style>
</head>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/13.8.9/Tone.js"></script>
<body onload="init();">
    <div id='reading'></div>
    whami <input type="checkbox" id="whami" onclick="toggleWhami()">
    <div id='container'></div>
<script>
    var whamiOn = false
    const toggleWhami = () =>{
        whamiOn = !whamiOn
    }


    var octave = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']
    var firstOctave = 3
    var lastOctave = 6
    var notes = []
    for (let index = firstOctave; index < lastOctave; index++) {
        octave.forEach(note => {
            notes.push(note  + index)
        });
    }

    let noteIndex = 0
    var reversed = octave.reverse()
    for (let index = firstOctave; index < lastOctave; index++) {
        var octaveContainer = document.createElement('div')
        octaveContainer.id = 'octave' + index
        octaveContainer.className = 'octaveContainer'
        document.getElementById('container').appendChild(octaveContainer)
        reversed.forEach(note => {
            var el = document.createElement('div')
            el.innerHTML = note + index
            el.id = note + index
            if (note.endsWith('#')) {
                el.className = 'key black'
            } else {
                el.className = 'key white'
            }
            document.getElementById(octaveContainer.id ).appendChild(el)
        });
    }
    let peaking = new Tone.Filter(0, "peaking").toMaster()
    var bandWidth = new Tone.Filter({
            "rolloff": -48,
            "frequency": 0,
            "Q": 2,
        }).connect(peaking)
    // var effect = new Tone.AutoWah().toMaster()
    // var effect = new Tone.Distortion(0.8).connect(wah)
    const POLYPHONY = 1
    var synth = new Tone.PolySynth(POLYPHONY, Tone.Synth, {
        oscillator: {
            type: 'triangle'
        }
        ,
        envelope: {
            attack: 0.5,
            decay: 0.1,
            sustain: 0.3,
            release: 1
        }
    }).connect(bandWidth)

    var notesMapping = {}
    for (const pitch of notes) {
        notesMapping[pitch] = {}
    }




    function startNote(ev) {
        ev.preventDefault();
        ev.target.style.background = "yellow";
        let noteName = ev.target.id
        synth.triggerAttack(noteName)
        let voiceIndex = synth._getClosestVoice(undefined, noteName).index
        notesMapping[noteName] = {
            voiceIndex : voiceIndex ,
            start: {
                x: ev.targetTouches[0].clientX,
                y: ev.targetTouches[0].clientY,
            }
        }
    }

    function move_handler(ev) {
        // Note: if the user makes more than one "simultaneous" touches, most browsers
        // fire at least one touchmove event and some will fire several touchmoves.
        // Consequently, an application might want to "ignore" some touchmoves.
        //
        // This function sets the target element's border to "dashed" to visualy
        // indicate the target received a move event.
        //
        let noteName = ev.target.id
        var threshold = 20
        let mappedNote = notesMapping[noteName]
        let voiceIndex = mappedNote.voiceIndex


        var vibrate = mappedNote.start.x - ev.targetTouches[0].clientX
        var movedY = mappedNote.start.y - ev.targetTouches[0].clientY
        // place.synth.vibrate.value = vibrate
        if(!isNaN(movedY) && Math.abs(movedY) > threshold){


            // place.vibrato.frequency.value = vibrate * 5 * 0.009 * 2
            // place.vibrato.depth.value = vibrate * 0.1  * 0.009 * 2
            if (whamiOn) {

            } else {
                let noteFreq = Tone.Frequency(noteName).valueOf()
                // console.log('noteFreq', noteFreq)
                let synthVoice = synth.voices.find(voice => {
                    let timeline = voice.frequency._events._timeline
                    console.log(timeline[timeline.length - 1])
                    return timeline[timeline.length - 1].value === noteFreq
                })
                if (synthVoice) {
                    console.log('not undef!')
                }
                if (movedY > 0) {
                    synthVoice.detune.value = movedY - threshold
                } else {
                    synthVoice.detune.value = movedY + threshold
                }
            }
        }
    }
    function end_handler(ev) {
        synth.triggerRelease(ev.target.id)
        ev.preventDefault();
        if (ev.targetTouches.length == 0) {
            // Restore background and border to original values
            if (ev.target.id.includes('#') ) {
                ev.target.style.background = "grey";
            } else {
                ev.target.style.background = "white";
            }
            ev.target.style.border = "1px solid black";
        }
    }
    function set_handlers(name) {
        // Install event handlers for the given element
        var el = document.getElementById(name);
        el.ontouchstart = startNote
        // el.ontouchmove = move_handler;
        // Use same handler for touchcancel and touchend
        el.ontouchcancel = end_handler;
        el.ontouchend = end_handler;
    }
    function init() {
        for (const pitch of notes) {
            set_handlers(pitch);
        }
    }
    const detuneKeys = (cents, time) =>{
        synth.detune.rampTo(cents, time)
    }


    let accelerometer = new Accelerometer({ frequency: 60 });
    var reading = document.getElementById('reading')
    var up = false
    accelerometer.addEventListener('reading', e => {
        var sensorMin = 4
        var sensorMax = 4.2
        var adjusted = (accelerometer.y - sensorMin) / (sensorMax - sensorMin)
        var limited = Math.min(Math.max(adjusted, 0), 1)
        reading.innerHTML = limited
        if (whamiOn) {
            if (!up && limited === 1) {
                document.body.style.background = 'red'
                up = true
                detuneKeys(limited * 1200, 0.4)
            }
            if (up && limited === 0) {
                document.body.style.background = 'white'
                up = false
                detuneKeys(limited * 1200, 0)
            }
        } else {
            let tilt = (accelerometer.y + 5) / 2 * 700 + 300
            peaking.frequency.value = tilt
            bandWidth.frequency.value = tilt
            let hue = accelerometer.y * 10
            document.body.style.background = `hsl(${hue},100%,50%)`;
        }
    })

    accelerometer.start()
</script>
</body>

</html>

